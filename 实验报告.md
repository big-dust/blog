# 个人博客系统实验报告

## 一、实验目标

这次实验主要是想做一个自己的博客网站，通过这个项目来学习Web开发。具体想达到的目标：

1. 学会前后端分离的开发方式，就是前端和后端分开写，通过接口通信
2. 学习React框架，之前只学过HTML/CSS/JS，想试试现在流行的框架
3. 学习Node.js后端开发，用Express搭建API服务
4. 练习MySQL数据库的使用，设计表结构和写SQL语句
5. 了解用户登录认证是怎么实现的（JWT token那些）
6. 把学到的东西整合起来，做一个能用的项目

## 二、实验内容

做了一个博客系统，有前台和后台两部分。

### 2.1 前台（给访客看的）
- 首页显示文章列表，有分页
- 点进去能看文章详情，支持Markdown
- 可以按分类看文章
- 可以按标签筛选
- 有搜索功能
- 可以评论，还能回复别人的评论
- 能看到文章被看了多少次

### 2.2 后台（管理员用的）
- 登录功能
- 写文章、改文章、删文章
- 管理分类和标签
- 上传图片

## 三、实验工具和开发平台

### 3.1 开发环境
| 东西 | 说明 |
|------|------|
| 系统 | macOS |
| Node.js | v18 |
| 数据库 | MySQL 8.0 |
| 编辑器 | VS Code |

### 3.2 前端用到的
| 技术 | 干嘛的 |
|------|--------|
| React | 前端框架，写页面用的 |
| React Router | 管理页面跳转 |
| marked | 把Markdown转成HTML |
| CSS | 写样式 |

### 3.3 后端用到的
| 技术 | 干嘛的 |
|------|--------|
| Express | 后端框架 |
| mysql2 | 连接MySQL数据库 |
| jsonwebtoken | 生成和验证token |
| bcryptjs | 给密码加密 |
| multer | 处理文件上传 |
| cors | 解决跨域问题 |

## 四、系统需求

### 4.1 功能需求

1. **文章功能**：能写文章、改文章、删文章，支持Markdown格式
2. **分类功能**：文章可以分类，能按分类筛选
3. **标签功能**：一篇文章可以有多个标签
4. **评论功能**：访客能评论，能回复
5. **搜索功能**：能搜文章
6. **登录功能**：管理员要登录才能管理文章
7. **浏览量**：记录文章被看了多少次

### 4.2 其他需求

- 页面要能适应不同屏幕大小
- 密码要加密存储
- 加载的时候要有提示

## 五、系统架构

### 5.1 整体结构

简单来说就是三层：浏览器 -> 后端服务器 -> 数据库

```
浏览器（React应用，跑在3000端口）
        ↓ 发HTTP请求
后端服务器（Express，跑在3001端口）
        ↓ 查数据库
MySQL数据库（3306端口）
```

### 5.2 前端目录结构

```
frontend/src/
├── components/     # 组件，可以复用的那种
│   ├── Header.js      # 顶部导航
│   ├── Footer.js      # 底部
│   ├── ArticleList.js # 文章列表
│   ├── CommentSection.js # 评论区
│   └── ...
├── pages/          # 页面
│   ├── HomePage.js    # 首页
│   ├── ArticleDetail.js # 文章详情页
│   ├── AdminPanel.js  # 后台管理页
│   └── ...
├── services/       # 调接口的
│   ├── api.js         # 封装的请求方法
│   └── ...
├── contexts/       # 全局状态
│   └── AuthContext.js # 登录状态
└── App.js          # 入口
```

### 5.3 后端目录结构

```
backend/src/
├── server.js       # 入口文件
├── config/
│   └── database.js    # 数据库配置
├── middleware/
│   └── auth.js        # 验证token的中间件
├── routes/         # 各种接口
│   ├── articles.js    # 文章相关
│   ├── auth.js        # 登录相关
│   ├── categories.js  # 分类
│   ├── tags.js        # 标签
│   ├── comments.js    # 评论
│   └── ...
└── utils/
    └── database.js    # 数据库工具方法
```

### 5.4 数据库设计

一共5张表：

- **users** - 用户表，存管理员账号
- **articles** - 文章表
- **categories** - 分类表
- **tags** - 标签表
- **article_tags** - 文章和标签的关联（因为是多对多关系）
- **comments** - 评论表

表之间的关系大概是这样：
```
users 1--n articles（一个用户可以写多篇文章）
categories 1--n articles（一个分类下可以有多篇文章）
articles n--n tags（通过article_tags关联）
articles 1--n comments（一篇文章可以有多条评论）
comments 可以自己关联自己（parent_id实现回复功能）
```

## 六、核心模块 / 关键问题和解决方法

### 6.1 用户登录认证

**遇到的问题**：怎么判断用户有没有登录？怎么保护那些需要登录才能用的接口？

**怎么解决的**：用JWT（JSON Web Token）

流程是这样的：
1. 用户输入账号密码登录
2. 后端验证对了之后，生成一个token返回给前端
3. 前端把token存到localStorage里
4. 之后每次请求都在header里带上这个token
5. 后端有个中间件专门检查token对不对

### 6.2 文章和标签的多对多关系

**遇到的问题**：一篇文章可以有多个标签，一个标签也可以属于多篇文章，这种关系怎么存？

**怎么解决的**：建一个中间表article_tags，里面就两个字段：article_id和tag_id

查询的时候用JOIN把它们连起来，用GROUP_CONCAT把多个标签合并成一个字符串。

### 6.3 评论的嵌套回复

**遇到的问题**：评论要能回复，回复还能再回复，怎么实现？

**怎么解决的**：在comments表里加一个parent_id字段，指向被回复的那条评论。如果是顶级评论，parent_id就是null。

查出来之后在代码里构建成树形结构再返回给前端。

### 6.4 跨域问题

**遇到的问题**：前端跑在3000端口，后端跑在3001端口，浏览器不让请求。

**怎么解决的**：后端装个cors中间件，配置一下允许3000端口访问就行了。

```javascript
app.use(cors({
  origin: 'http://localhost:3000',
  credentials: true
}));
```

### 6.5 Markdown渲染

**遇到的问题**：文章内容是Markdown格式的，要在页面上显示成正常的样式。

**怎么解决的**：用marked这个库，把Markdown字符串转成HTML，然后用React的dangerouslySetInnerHTML渲染出来。

## 七、重要代码

### 7.1 后端入口文件

```javascript
// backend/src/server.js
const express = require('express');
const cors = require('cors');
require('dotenv').config();

const { initDatabase } = require('./config/database');

// 引入路由
const articlesRoutes = require('./routes/articles');
const authRoutes = require('./routes/auth');
const categoriesRoutes = require('./routes/categories');
const tagsRoutes = require('./routes/tags');
const commentsRoutes = require('./routes/comments');
const uploadRoutes = require('./routes/upload');

const app = express();
const PORT = process.env.PORT || 3001;

// 跨域
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));
app.use(express.json({ limit: '10mb' }));
app.use('/uploads', express.static('uploads'));

// 注册路由
app.use('/api/articles', articlesRoutes);
app.use('/api/auth', authRoutes);
app.use('/api/categories', categoriesRoutes);
app.use('/api/tags', tagsRoutes);
app.use('/api/comments', commentsRoutes);
app.use('/api/upload', uploadRoutes);

// 启动
const startServer = async () => {
  await initDatabase();
  app.listen(PORT, () => {
    console.log(`服务器跑在 ${PORT} 端口`);
  });
};

startServer();
```

### 7.2 JWT认证中间件

```javascript
// backend/src/middleware/auth.js
const jwt = require('jsonwebtoken');

// 检查token
const checkToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: '没有token' });
  }

  jwt.verify(token, process.env.JWT_SECRET, (err, decoded) => {
    if (err) {
      // token过期或者无效
      return res.status(403).json({ error: 'token无效' });
    }
    req.user = decoded;
    next();
  });
};

// 生成token
const makeToken = (data, expiresIn = '24h') => {
  return jwt.sign(data, process.env.JWT_SECRET, { expiresIn });
};

module.exports = { checkToken, makeToken };
```

### 7.3 获取文章列表接口

```javascript
// backend/src/routes/articles.js
router.get('/', async (req, res) => {
  try {
    const { page = 1, limit = 10, category_id, tag_id } = req.query;

    let sql = `
      SELECT 
        a.id, a.title, a.summary, a.view_count, a.created_at,
        u.username as author_name,
        c.name as category_name, c.id as category_id,
        GROUP_CONCAT(DISTINCT t.name) as tags,
        GROUP_CONCAT(DISTINCT t.id) as tag_ids
      FROM articles a
      LEFT JOIN users u ON a.author_id = u.id
      LEFT JOIN categories c ON a.category_id = c.id
      LEFT JOIN article_tags at ON a.id = at.article_id
      LEFT JOIN tags t ON at.tag_id = t.id
    `;

    const params = [];
    const conditions = [];

    if (category_id) {
      conditions.push('a.category_id = ?');
      params.push(category_id);
    }
    if (tag_id) {
      conditions.push('at.tag_id = ?');
      params.push(tag_id);
    }

    if (conditions.length > 0) {
      sql += ' WHERE ' + conditions.join(' AND ');
    }
    sql += ' GROUP BY a.id ORDER BY a.created_at DESC';

    // 分页查询
    const result = await DatabaseUtils.paginate(sql, params, parseInt(page), parseInt(limit));
    res.json({ success: true, data: result.data, pagination: result.pagination });
  } catch (e) {
    console.log('获取文章失败:', e.message);
    res.status(500).json({ error: '获取文章失败' });
  }
});
```

### 7.4 前端路由配置

```javascript
// frontend/src/App.js
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import Header from './components/Header';
import Footer from './components/Footer';
import HomePage from './pages/HomePage';
import ArticleDetail from './pages/ArticleDetail';
import CategoryPage from './pages/CategoryPage';
import TagPage from './pages/TagPage';
import SearchResults from './pages/SearchResults';
import AdminPanel from './pages/AdminPanel';

function App() {
  return (
    <AuthProvider>
      <Router>
        <div className="App">
          <Header />
          <main className="main-content">
            <Routes>
              <Route path="/" element={<HomePage />} />
              <Route path="/article/:id" element={<ArticleDetail />} />
              <Route path="/category/:id" element={<CategoryPage />} />
              <Route path="/tag/:id" element={<TagPage />} />
              <Route path="/search" element={<SearchResults />} />
              <Route path="/admin" element={<AdminPanel />} />
            </Routes>
          </main>
          <Footer />
        </div>
      </Router>
    </AuthProvider>
  );
}

export default App;
```

### 7.5 封装HTTP请求

```javascript
// frontend/src/services/api.js
const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';

// 管理token
class AuthManager {
  static TOKEN_KEY = 'blog_auth_token';

  static getToken() {
    return localStorage.getItem(this.TOKEN_KEY);
  }
  static setToken(token) {
    localStorage.setItem(this.TOKEN_KEY, token);
  }
  static removeToken() {
    localStorage.removeItem(this.TOKEN_KEY);
  }
}

// 发请求
class HTTPClient {
  async request(endpoint, options = {}) {
    const headers = { 'Content-Type': 'application/json' };
    const token = AuthManager.getToken();
    if (token) headers.Authorization = `Bearer ${token}`;

    const response = await fetch(`${API_URL}${endpoint}`, {
      ...options,
      headers
    });

    if (!response.ok) {
      throw new Error('请求失败');
    }
    return response.json();
  }

  get(endpoint) {
    return this.request(endpoint, { method: 'GET' });
  }
  post(endpoint, data) {
    return this.request(endpoint, { method: 'POST', body: JSON.stringify(data) });
  }
  put(endpoint, data) {
    return this.request(endpoint, { method: 'PUT', body: JSON.stringify(data) });
  }
  delete(endpoint) {
    return this.request(endpoint, { method: 'DELETE' });
  }
}

export { AuthManager };
export default new HTTPClient();
```

### 7.6 登录状态管理

```javascript
// frontend/src/contexts/AuthContext.js
import { createContext, useContext, useState, useEffect } from 'react';
import authService from '../services/authService';

const AuthContext = createContext();

export function useAuth() {
  return useContext(AuthContext);
}

export function AuthProvider({ children }) {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [user, setUser] = useState(null);

  useEffect(() => {
    // 页面加载时检查有没有登录
    const auth = authService.isAuthenticated();
    setIsAuthenticated(auth);
  }, []);

  const login = async (credentials) => {
    const res = await authService.login(credentials);
    setIsAuthenticated(true);
    setUser(res.user);
    return res;
  };

  const logout = async () => {
    await authService.logout();
    setIsAuthenticated(false);
    setUser(null);
  };

  return (
    <AuthContext.Provider value={{ isAuthenticated, user, login, logout }}>
      {children}
    </AuthContext.Provider>
  );
}
```

### 7.7 评论嵌套处理

```javascript
// 后端构建嵌套结构
router.get('/:id/comments', async (req, res) => {
  const { id } = req.params;

  const comments = await db.query(`
    SELECT id, article_id, parent_id, nickname, content, created_at 
    FROM comments WHERE article_id = ? ORDER BY created_at ASC
  `, [id]);

  // 构建树形结构
  const map = new Map();
  const rootComments = [];

  // 先把所有评论放到map里
  comments.forEach(c => {
    map.set(c.id, { ...c, replies: [] });
  });

  // 然后把回复挂到对应的评论下面
  comments.forEach(c => {
    const obj = map.get(c.id);
    if (c.parent_id) {
      const parent = map.get(c.parent_id);
      if (parent) parent.replies.push(obj);
    } else {
      rootComments.push(obj);
    }
  });

  res.json({ success: true, data: rootComments });
});
```

### 7.8 数据库表结构

```sql
-- 用户表
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 分类表
CREATE TABLE categories (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) UNIQUE NOT NULL,
    description TEXT
);

-- 文章表
CREATE TABLE articles (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(200) NOT NULL,
    content LONGTEXT NOT NULL,
    summary TEXT,
    author_id INT NOT NULL,
    category_id INT,
    view_count INT DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (author_id) REFERENCES users(id),
    FOREIGN KEY (category_id) REFERENCES categories(id)
);

-- 标签表
CREATE TABLE tags (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) UNIQUE NOT NULL,
    color VARCHAR(7) DEFAULT '#007bff'
);

-- 文章标签关联表
CREATE TABLE article_tags (
    article_id INT,
    tag_id INT,
    PRIMARY KEY (article_id, tag_id),
    FOREIGN KEY (article_id) REFERENCES articles(id),
    FOREIGN KEY (tag_id) REFERENCES tags(id)
);

-- 评论表
CREATE TABLE comments (
    id INT PRIMARY KEY AUTO_INCREMENT,
    article_id INT NOT NULL,
    parent_id INT DEFAULT NULL,
    nickname VARCHAR(50) NOT NULL,
    email VARCHAR(100) NOT NULL,
    content TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (article_id) REFERENCES articles(id),
    FOREIGN KEY (parent_id) REFERENCES comments(id)
);
```

## 八、实验总结

通过这次实验，我完成了一个前后端分离的个人博客系统，前端用React，后端用Express和MySQL。实现了文章管理、分类标签、评论、搜索、登录认证等功能。过程中遇到了跨域、token验证、文件上传等问题，通过查资料和不断调试都解决了。这次实验让我对Web开发有了更完整的认识，也积累了一些实际项目的经验。
